# -*- coding: utf-8 -*-
import logging
import json
import requests
from datetime import timedelta
from urllib.parse import urlsplit, urlunsplit

from odoo import api, fields, models, _
from odoo.exceptions import UserError

_logger = logging.getLogger(__name__)


# --------------------------
# URL helpers
# --------------------------
def _normalize_origin(u: str) -> str:
    """Return scheme://host[:port] with no path/query/fragment."""
    u = (u or "").strip()
    sp = urlsplit(u)
    if not sp.scheme or not sp.netloc:
        raise UserError(_("Invalid API Base URL: %s") % (u or "<empty>"))
    return urlunsplit((sp.scheme, sp.netloc, "", "", ""))


def _api_url(origin: str, path: str) -> str:
    """Join origin + /api + path safely (path may start with /)."""
    p = (path or "").strip()
    if not p.startswith("/"):
        p = "/" + p
    # Always mount under /api/<...>
    return f"{origin}/api{p}"


class BiostarDevice(models.Model):
    _name = "biostar.device"
    _description = "Suprema BioStar Device"
    _inherit = ['mail.thread', 'mail.activity.mixin']

    # --------------------------
    # Fields
    # --------------------------
    name = fields.Char(required=True, tracking=True)
    base_url = fields.Char(
        "API Base URL", required=True,
        help="Origin only (no /api). Example: https://10.201.2.88:5002"
    )
    username = fields.Char(required=True)
    password = fields.Char(required=True)
    verify_ssl = fields.Boolean(default=False)
    device_ip = fields.Char("Device IP")
    timezone = fields.Char(default="UTC")
    token = fields.Char("Session Token", readonly=True)
    token_expires = fields.Datetime(readonly=True)

    active = fields.Boolean(default=True)
    last_user_sync = fields.Datetime(readonly=True)
    last_event_sync = fields.Datetime(readonly=True)
    status = fields.Selection(
        [('unknown', 'Unknown'), ('ok', 'OK'), ('error', 'Error')],
        default='unknown', readonly=True
    )
    status_message = fields.Char(readonly=True)

    user_ids = fields.One2many('biostar.user', 'device_id', string="Users")

    # --------------------------
    # Internals / utilities
    # --------------------------
    def _safe_write(self, rec, vals):
        """Bypass any accidental shadowing of instance .write."""
        return type(rec).write(rec, vals)

    def _session(self):
        s = requests.Session()
        s.verify = bool(self.verify_ssl)
        # Some BioStar installs are picky about these headers
        origin = _normalize_origin(self.base_url)
        s.headers.update({
            "Accept": "application/json",
            "Content-Type": "application/json",
            "User-Agent": "Odoo-BioStar/1.0",
            "X-Requested-With": "XMLHttpRequest",
            "Origin": origin,
            "Referer": origin + "/",
        })
        return s

    def _login(self):
        """Login and return a record with fresh cookies/session in its context."""
        for rec in self:
            origin = _normalize_origin(rec.base_url)
            url = _api_url(origin, "/login")
            payload = {"User": {"login_id": rec.username, "password": rec.password}}

            s = rec._session()
            r = s.post(url, json=payload, timeout=30, allow_redirects=False)

            bs_sid = r.headers.get("bs-session-id")
            ok = (r.status_code == 200) or bool(bs_sid)
            if not ok:
                raise UserError(_("Login failed (%s): %s") % (r.status_code, r.text or r.reason))

            cookies = s.cookies.get_dict()
            if bs_sid:
                # Some versions require it both as cookie & header later
                cookies["bs-session-id"] = bs_sid

            # Store a marker token (cookie-based sessions donâ€™t return tokens)
            self._safe_write(rec, {
                "token": "COOKIE",
                "token_expires": fields.Datetime.now() + timedelta(hours=1),
            })

            # Return a *contexted* record with session bits for _req()
            return rec.with_context(_cookies=cookies, _bs_sid=bs_sid or "")
        return self

    def _req(self, method, path, **kw):
        """Do a request under /api/<path>. Retry once on 401/419 by re-login."""
        self.ensure_one()
        origin = _normalize_origin(self.base_url)
        url = _api_url(origin, path)

        s = self._session()

        # restore session
        cookies = dict(self.env.context.get('_cookies') or {})
        if cookies:
            s.cookies.update(cookies)
        bs_sid = self.env.context.get('_bs_sid')
        if bs_sid:
            s.headers["bs-session-id"] = bs_sid

        r = s.request(method.upper(), url, timeout=60, **kw)

        if r.status_code in (401, 419):  # expired/missing session
            recc = self._login()
            s = recc._session()
            cookies = dict(recc.env.context.get('_cookies') or {})
            if cookies:
                s.cookies.update(cookies)
            bs_sid = recc.env.context.get('_bs_sid')
            if bs_sid:
                s.headers["bs-session-id"] = bs_sid
            r = s.request(method.upper(), url, timeout=60, **kw)

        r.raise_for_status()
        if not r.text:
            return {}
        try:
            return r.json()
        except Exception:
            return {"_raw": r.text}

    # --------------------------
    # Parsing helpers
    # --------------------------
    def _extract_users(self, payload):
        """Return a flat list of user dicts or strings from any BioStar response."""
        if payload is None:
            return []

        # String? try to load JSON, otherwise treat as lines/ids
        if isinstance(payload, str):
            s = payload.strip()
            if s and s[0] in "[{":
                try:
                    payload = json.loads(s)
                except Exception:
                    return [line.strip() for line in s.splitlines() if line.strip()]
            else:
                return [line.strip() for line in s.splitlines() if line.strip()]

        # Envelope with error?
        if isinstance(payload, dict) and isinstance(payload.get("Response"), dict):
            if payload["Response"].get("code") not in (None, 0):
                _logger.warning("BioStar Response error: %s", payload["Response"])
                return []

        # Exact BioStar shape: {"UserCollection":{"rows":[...]}}
        if isinstance(payload, dict):
            uc = payload.get("UserCollection")
            if isinstance(uc, dict) and isinstance(uc.get("rows"), list) and uc["rows"]:
                return uc["rows"]

        out = []

        def looks_like_user(d):
            if not isinstance(d, dict):
                return False
            keys = {k.lower() for k in d.keys()}
            return bool(keys & {"user_id", "id", "userid", "usercode", "user_code"}) or \
                   ("name" in keys or "username" in keys or "display_name" in keys)

        def walk(x):
            if x is None:
                return
            if isinstance(x, dict):
                if looks_like_user(x):
                    out.append(x)
                for k, v in x.items():
                    if k in ("records", "data", "users", "UserList", "UserCollection",
                             "Items", "results", "items", "rows"):
                        walk(v)
                    else:
                        walk(v)
            elif isinstance(x, list):
                for i in x:
                    walk(i)
            elif isinstance(x, str):
                s = x.strip()
                if s:
                    out.append(s)

        walk(payload)
        return out

    # --------------------------
    # Buttons / public API
    # --------------------------
    def action_test_connection(self):
        for rec in self:
            try:
                recc = rec._login()
                # Prefer a permissive endpoint first
                try:
                    _ = recc._req("POST", "/devices/search", json={"Query": {}, "Limit": 1})
                except Exception:
                    _ = recc._req("GET", "/system")

                rec.write( {"status": "ok", "status_message": "Connected"})
            except Exception as e:
                _logger.exception("BioStar test failed")
                self._safe_write(rec, {"status": "error", "status_message": str(e)})
                raise
        return True

    def action_import_users(self):
        """Create/update biostar.user records from BioStar."""
        BiostarUser = self.env['biostar.user'].sudo()

        for rec in self:
            recc = rec._login()

            items = []
            raw_samples = []

            # 1) Try POST /api/users/search with pagination
            try:
                limit, offset, loops = 200, 0, 0
                while True:
                    body = {"Query": {}, "Limit": limit, "Offset": offset}
                    data = recc._req("POST", "/users/search", json=body)
                    if len(raw_samples) < 2:
                        raw_samples.append(str(data)[:600])
                    chunk = recc._extract_users(data)
                    if not chunk:
                        break
                    items.extend(chunk)
                    if len(chunk) < limit:
                        break
                    offset += limit
                    loops += 1
                    if loops > 50:  # safety
                        break
            except Exception as e:
                _logger.info("POST /api/users/search failed: %s", e)

            # 2) Fallback GET /api/users?limit=&offset=
            if not items:
                try:
                    limit, offset, loops = 200, 0, 0
                    while True:
                        data = recc._req("GET", f"/users?limit={limit}&offset={offset}")
                        if len(raw_samples) < 2:
                            raw_samples.append(str(data)[:600])
                        chunk = recc._extract_users(data)
                        if not chunk:
                            break
                        items.extend(chunk)
                        if len(chunk) < limit:
                            break
                        offset += limit
                        loops += 1
                        if loops > 50:
                            break
                except Exception as e:
                    _logger.info("GET /api/users fallback failed: %s", e)

            # Optional probe (helps diagnose permissions)
            if not items:
                try:
                    _ = recc._req("POST", "/devices/search", json={"Query": {}, "Limit": 1})
                except Exception as e:
                    _logger.info("POST /api/devices/search probe failed: %s", e)

            if not items:
                _logger.warning("No users extracted. Samples: %s", " | ".join(raw_samples) or "<empty>")
                # toast notify; do not fail the button
                try:
                    self.env['bus.bus']._sendone(
                        self.env.user.partner_id, 'simple_notification',
                        {'title': _('BioStar'),
                         'message': _("User import: no users returned (check API user permissions/endpoint)."),
                         'sticky': False}
                    )
                except Exception:
                    pass
                continue

            created, updated = 0, 0
            now = fields.Datetime.now()

            for u in items:
                if isinstance(u, str):
                    uid = u.strip()
                    name = uid
                    card = None
                else:
                    # dict-like
                    uid = str(
                        u.get("user_id") or u.get("id") or u.get("user_code") or
                        u.get("userID") or u.get("UserID") or u.get("code") or ""
                    ).strip()
                    name = (u.get("name") or u.get("display_name") or u.get("UserName") or uid or "").strip()
                    card = u.get("card") or u.get("card_no") or u.get("CardNo") or u.get("rfid")
                    if card is not None:
                        card = str(card).strip()

                if not uid:
                    continue

                rec_user = BiostarUser.search([
                    ('device_id', '=', rec.id),
                    ('biostar_user_id', '=', uid)
                ], limit=1)

                vals = {"name": name or uid}
                if card:
                    vals["card_no"] = card

                if rec_user:
                    type(rec_user).write(rec_user, vals)  # safe write
                    updated += 1
                else:
                    vals.update({"device_id": rec.id, "biostar_user_id": uid})
                    BiostarUser.create(vals)
                    created += 1

            # update sync timestamp and notify (safely)
            self._safe_write(rec, {'last_user_sync': now})
            try:
                self.env['bus.bus']._sendone(
                    self.env.user.partner_id, 'simple_notification',
                    {'title': _('BioStar'),
                     'message': _("User import finished. Created: %s, Updated: %s") % (created, updated),
                     'sticky': False}
                )
            except Exception:
                pass

        return True

    # (Optional) Example event pull stub kept from your version.
    # You can flesh this out against your actual event API later.
    def action_pull_events(self, since=None, until=None):
        """Fetch attendance events and create hr.attendance (basic alternating IN/OUT)."""
        Attendance = self.env['hr.attendance'].sudo()
        Employee = self.env['hr.employee'].sudo()

        for rec in self:
            recc = rec._login()

            # default range: last 24h
            since_dt = fields.Datetime.from_string(since) if since else (fields.Datetime.now() - timedelta(days=1))
            until_dt = fields.Datetime.from_string(until) if until else fields.Datetime.now()

            payload = {
                "start_datetime": since_dt.strftime("%Y-%m-%dT%H:%M:%SZ"),
                "end_datetime": until_dt.strftime("%Y-%m-%dT%H:%M:%SZ"),
            }
            try:
                events = recc._req("POST", "/events/search", json=payload)
            except Exception as e:
                _logger.exception("Events pull failed: %s", e)
                continue

            items = (events or {}).get("records") or events.get("events") or []
            created = 0
            for ev in items:
                uid = str(ev.get("user_id") or ev.get("user_code") or "").strip()
                ts = ev.get("event_time") or ev.get("datetime")
                if not uid or not ts:
                    continue
                punch_dt = fields.Datetime.to_datetime(ts)

                emp = Employee.search([('barcode', '=', uid)], limit=1)
                if not emp:
                    bs_user = self.env['biostar.user'].sudo().search([
                        ('device_id', '=', rec.id),
                        ('biostar_user_id', '=', uid),
                        ('employee_id', '!=', False)
                    ], limit=1)
                    emp = bs_user.employee_id

                if not emp:
                    _logger.warning("BioStar event with unknown user %s", uid)
                    continue

                last = Attendance.search([('employee_id', '=', emp.id)], order='check_in desc', limit=1)
                if not last or last.check_out:
                    Attendance.create({"employee_id": emp.id, "check_in": punch_dt})
                    created += 1
                else:
                    if punch_dt > last.check_in:
                        last.write({"check_out": punch_dt})

            self._safe_write(rec, {'last_event_sync': fields.Datetime.now()})
            try:
                self.env['bus.bus']._sendone(
                    self.env.user.partner_id, 'simple_notification',
                    {'title': _('BioStar'),
                     'message': _("Events pulled: %s records processed") % created,
                     'sticky': False}
                )
            except Exception:
                pass

        return True
