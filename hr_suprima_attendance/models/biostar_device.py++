import logging
import requests
from datetime import datetime, timedelta
from odoo import api, fields, models, _
from odoo.exceptions import UserError

_logger = logging.getLogger(__name__)

def _clean_url(u):
    return (u or "").rstrip("/")

class BiostarDevice(models.Model):
    _name = "biostar.device"
    _description = "Suprema BioStar Device"
    _inherit = ['mail.thread', 'mail.activity.mixin']  # <-- add this

    name = fields.Char(required=True)
    base_url = fields.Char("API Base URL", required=True,
                           help="e.g. http://10.4.30.7 or https://biostar.domain.com")
    username = fields.Char(required=True)
    password = fields.Char(required=True)
    verify_ssl = fields.Boolean(default=False)
    device_ip = fields.Char("Device IP")
    timezone = fields.Char(default="UTC")
    token = fields.Char("Session Token", readonly=True)
    token_expires = fields.Datetime(readonly=True)

    active = fields.Boolean(default=True)
    last_user_sync = fields.Datetime(readonly=True)
    last_event_sync = fields.Datetime(readonly=True)
    status = fields.Selection([
        ('unknown','Unknown'),
        ('ok','OK'),
        ('error','Error'),
    ], default='unknown', readonly=True)
    status_message = fields.Char(readonly=True)

    user_ids = fields.One2many('biostar.user', 'device_id', string="Users")

    # --------------------------
    # HTTP helpers
    # --------------------------
    

    def _session(self):
        s = requests.Session()
        s.verify = self.verify_ssl
        s.headers.update({
            "Accept": "application/json",
            "Content-Type": "application/json",
            # mimic Postman a bit (some BioStar setups are picky)
            "User-Agent": "Odoo-BioStar/1.0",
            "Origin": _clean_url(self.base_url),
            "Referer": _clean_url(self.base_url) + "/",
        })
        return s

    def _login(self):
        for rec in self:
            base = _clean_url(rec.base_url)
            url  = f"{base}/api/login"
            payload = {"User": {"login_id": rec.username, "password": rec.password}}

            s = rec._session()
            r = s.post(url, json=payload, timeout=30, allow_redirects=False)

            bs_sid = r.headers.get("bs-session-id")
            ok = (r.status_code == 200) or bool(bs_sid)
            if not ok:
                raise UserError(_("Login failed (%s): %s") % (r.status_code, r.text or r.reason))

            cookies = s.cookies.get_dict()
            if bs_sid:
                cookies["bs-session-id"] = bs_sid

            rec.token = "COOKIE"
            rec.token_expires = fields.Datetime.now() + timedelta(hours=1)

            # IMPORTANT: return the record WITH context (cookies + bs_sid)
            return rec.with_context(_cookies=cookies, _bs_sid=bs_sid or "")
        return self  # fallback
    
    def _req(self, method, path, **kw):
        self.ensure_one()
        base = _clean_url(self.base_url)
        url  = f"{base}{path if path.startswith('/') else '/' + path}"

        s = self._session()
        cookies = dict(self.env.context.get('_cookies') or {})
        if cookies:
            s.cookies.update(cookies)

        bs_sid = self.env.context.get('_bs_sid')
        if bs_sid:
            s.headers["bs-session-id"] = bs_sid

        r = s.request(method, url, timeout=60, **kw)

        if r.status_code in (401, 419):
            recc = self._login()  # get a record with fresh cookies in its context
            s = recc._session()
            cookies = dict(recc.env.context.get('_cookies') or {})
            if cookies:
                s.cookies.update(cookies)
            bs_sid = recc.env.context.get('_bs_sid')
            if bs_sid:
                s.headers["bs-session-id"] = bs_sid
            r = s.request(method, url, timeout=60, **kw)

        r.raise_for_status()
        return r.json() if r.text else {}

    def _auth_headers(self):
        if self.token and self.token != "COOKIE":
            return {"Authorization": f"Bearer {self.token}"}
        return {}
    
    def _safe_message_post(self, rec, body, **kw):
        """Post to chatter safely even if message_post is shadowed. Falls back to bus/log."""
        try:
            # call the method on the class, passing the record
            type(rec).message_post(rec, body=body, **kw)
        except Exception as e:
            _logger.info("message_post failed (%s); falling back to bus/log", e)
            # lightweight toast to current user (no chatter required)
            try:
                self.env['bus.bus']._sendone(
                    self.env.user.partner_id,
                    'simple_notification',
                    {'title': _('BioStar'), 'message': body, 'sticky': False}
                )
            except Exception:
                _logger.info("Bus fallback failed; logging only: %s", body)


    # def _extract_users(self, payload):
    #     """Return a flat list of user dicts or strings from any BioStar user response shape."""
    #     if payload is None:
    #         return []

    #     # If server returned an error envelope, bail out
    #     if isinstance(payload, dict) and "Response" in payload and isinstance(payload["Response"], dict):
    #         if payload["Response"].get("code") not in (None, 0):
    #             _logger.warning("BioStar Response error: %s", payload["Response"])
    #             return []

    #     out = []

    #     def looks_like_user(d):
    #         if not isinstance(d, dict):
    #             return False
    #         keys = set(k.lower() for k in d.keys())
    #         # Heuristics: common user identifiers
    #         return bool(keys & {"user_id", "id", "userid", "usercode", "user_code"}) or \
    #             ("name" in keys or "username" in keys or "display_name" in keys)

    #     def walk(x):
    #         if x is None:
    #             return
    #         if isinstance(x, dict):
    #             # direct user dict
    #             if looks_like_user(x):
    #                 out.append(x)
    #             # nested containers: pick common collection fields, otherwise scan all values
    #             for k, v in x.items():
    #                 if k in ("records", "data", "users", "UserList", "UserCollection", "Items", "results", "items"):
    #                     walk(v)
    #                 else:
    #                     walk(v)
    #         elif isinstance(x, list):
    #             for i in x:
    #                 walk(i)
    #         elif isinstance(x, str):
    #             # sometimes server returns lines of user ids
    #             s = x.strip()
    #             if s:
    #                 out.append(s)

    #     walk(payload)
    #     return out
    # def _extract_users(self, payload):
    #     """Return a flat list of user dicts or strings from any BioStar user response shape."""
    #     if payload is None:
    #         return []

    #     # Envelope error?
    #     if isinstance(payload, dict) and "Response" in payload and isinstance(payload["Response"], dict):
    #         if payload["Response"].get("code") not in (None, 0):
    #             _logger.warning("BioStar Response error: %s", payload["Response"])
    #             return []

    #     # --- Special case for BioStar: UserCollection.rows
    #     if isinstance(payload, dict):
    #         uc = payload.get("UserCollection")
    #         if isinstance(uc, dict):
    #             rows = uc.get("rows")
    #             if isinstance(rows, list) and rows:
    #                 return rows

    #     out = []

    #     def looks_like_user(d):
    #         if not isinstance(d, dict):
    #             return False
    #         keys = {k.lower() for k in d.keys()}
    #         return bool(keys & {"user_id", "id", "userid", "usercode", "user_code"}) or \
    #             ("name" in keys or "username" in keys or "display_name" in keys)

    #     def walk(x):
    #         if x is None:
    #             return
    #         if isinstance(x, dict):
    #             if looks_like_user(x):
    #                 out.append(x)
    #             # scan common collections + everything else
    #             for k, v in x.items():
    #                 if k in ("records", "data", "users", "UserList", "UserCollection", "Items", "results", "items", "rows"):
    #                     walk(v)
    #                 else:
    #                     walk(v)
    #         elif isinstance(x, list):
    #             for i in x:
    #                 walk(i)
    #         elif isinstance(x, str):
    #             s = x.strip()
    #             if s:
    #                 out.append(s)

    #     walk(payload)
    #     return out

    def _extract_users(self, payload):
        """Return a flat list of user dicts or strings from any BioStar user response shape."""
        if payload is None:
            return []

        # If JSON came as string, try to parse
        if isinstance(payload, str):
            s = payload.strip()
            if s and s[0] in "[{":
                try:
                    import json
                    payload = json.loads(s)
                except Exception:
                    # fall through, treat as plain string list
                    return [line.strip() for line in s.splitlines() if line.strip()]
            else:
                return [line.strip() for line in s.splitlines() if line.strip()]

        # Envelope error?
        if isinstance(payload, dict) and "Response" in payload and isinstance(payload["Response"], dict):
            if payload["Response"].get("code") not in (None, 0):
                _logger.warning("BioStar Response error: %s", payload["Response"])
                return []

        # --- Exact BioStar shape: UserCollection.rows
        if isinstance(payload, dict):
            uc = payload.get("UserCollection")
            if isinstance(uc, dict):
                rows = uc.get("rows")
                if isinstance(rows, list) and rows:
                    return rows

        out = []

        def looks_like_user(d):
            if not isinstance(d, dict):
                return False
            keys = {k.lower() for k in d.keys()}
            return bool(keys & {"user_id", "id", "userid", "usercode", "user_code"}) or \
                ("name" in keys or "username" in keys or "display_name" in keys)

        def walk(x):
            if x is None:
                return
            if isinstance(x, dict):
                if looks_like_user(x):
                    out.append(x)
                for k, v in x.items():
                    if k in ("records", "data", "users", "UserList", "UserCollection",
                            "Items", "results", "items", "rows"):
                        walk(v)
                    else:
                        walk(v)
            elif isinstance(x, list):
                for i in x:
                    walk(i)
            elif isinstance(x, str):
                s = x.strip()
                if s:
                    out.append(s)

        walk(payload)
        return out



    def action_import_users(self):
        for rec in self:
            rec._login()

            raw_samples = []   # for debug
            items = []

            # --- 1) Try POST /api/users/search with pagination variants
            # Some servers expect {"Query": {...}, "Limit": N, "Offset": M}
            try:
                limit = 200
                offset = 0
                total_loops = 0
                while True:
                    body = {"Query": {}, "Limit": limit, "Offset": offset}
                    data = rec._req("POST", "/api/users/search", json=body)
                    if isinstance(data, (dict, list)):
                        if len(raw_samples) < 2:
                            raw_samples.append(str(data)[:600])
                        chunk = rec._extract_users(data)
                        if not chunk:
                            break
                        items.extend(chunk)
                        # Try to detect end:
                        if len(chunk) < limit:
                            break
                        offset += limit
                        total_loops += 1
                        if total_loops > 50:  # safety
                            break
                    else:
                        break
            except Exception as e:
                _logger.info("POST /api/users/search failed: %s", e)

            # --- 2) Fallback GET /api/users with naive pagination (?limit/&offset)
            if not items:
                try:
                    limit = 200
                    offset = 0
                    loops = 0
                    while True:
                        sep = "&" if "?" in rec.base_url else "?"
                        data = rec._req("GET", f"/api/users?limit={limit}&offset={offset}")
                        # data = rec._req("GET", f"/api/users?limit={limit}&offset={offset}")
                        # (you can delete the unused 'sep' variable)

                        if isinstance(data, (dict, list)):
                            if len(raw_samples) < 2:
                                raw_samples.append(str(data)[:600])
                            chunk = rec._extract_users(data)
                            if not chunk:
                                break
                            items.extend(chunk)
                            if len(chunk) < limit:
                                break
                            offset += limit
                            loops += 1
                            if loops > 50:
                                break
                        else:
                            break
                except Exception as e:
                    _logger.info("GET /api/users fallback failed: %s", e)

            # --- 3) If still nothing, try the very permissive devices search (proves perms)
            if not items:
                try:
                    # _ = rec._req("POST", "/api/devices/search", json={"Query": {}, "Limit": 1})
                    dummy = rec._req("POST", "/api/devices/search", json={"Query": {}, "Limit": 1})
                except Exception as e:
                    _logger.info("POST /api/devices/search probe failed: %s", e)

            if not items:
                _logger.warning("No users extracted. First payload sample(s): %s", " | ".join(raw_samples) or "<empty>")
                # rec.message_post(body=_("BioStar user import: No users returned (check permissions/endpoint)."))
                # self._safe_message_post(rec, _("BioStar user import: No users returned (check permissions/endpoint)."))
                # self._notify(_("BioStar user import: No users returned (check permissions/endpoint)."))
                # SAFE notification: won't raise, won't rollback your import
                try:
                    self.env['bus.bus']._sendone(
                        self.env.user.partner_id,
                        'simple_notification',
                        {'title': _('BioStar'), 'message': _("User import finished. Created: %s, Updated: %s") % (created, updated), 'sticky': False}
                    )
                except Exception as e:
                    _logger.info("Notify failed: %s", e)


                continue

            # --- Normalize & upsert
            created, updated = 0, 0
            User = self.env['biostar.user'].sudo()
            now = fields.Datetime.now()

            for u in items:
                if isinstance(u, str):
                    uid = u.strip()
                    name = uid
                    card = None
                elif isinstance(u, dict):
                    uid = str(
                        u.get("user_id") or u.get("id") or u.get("user_code") or
                        u.get("userID") or u.get("UserID") or u.get("code") or ""
                    ).strip()
                    name = (u.get("name") or u.get("display_name") or u.get("UserName") or uid or "").strip()
                    card = u.get("card") or u.get("card_no") or u.get("CardNo") or u.get("rfid") or None
                    if card is not None:
                        card = str(card).strip()
                else:
                    _logger.debug("Skipping unknown user item: %r", u)
                    continue

                if not uid:
                    continue

                rec_user = User.search([
                    ('device_id', '=', rec.id),
                    ('biostar_user_id', '=', uid)
                ], limit=1)

                vals = {"name": name or uid}
                if card:
                    vals["card_no"] = card

                if rec_user:
                    type(rec_user).write(rec_user, vals)  # bypass any shadowed write
                    updated += 1
                else:
                    vals.update({"device_id": rec.id, "biostar_user_id": uid})
                    User.create(vals)
                    created += 1

            rec.last_user_sync = now
            type(rec).write(rec, {'last_user_sync': now})            # ✅
            # rec.message_post(body=_("User import finished. Created: %s, Updated: %s") % (created, updated))
            # self._notify(_("User import finished. Created: %s, Updated: %s") % (created, updated))
            # self._notify(_("BioStar user import: No users returned (check permissions/endpoint)."))
            # SAFE notification: won't raise, won't rollback your import
            try:
                self.env['bus.bus']._sendone(
                    self.env.user.partner_id,
                    'simple_notification',
                    {'title': _('BioStar'), 'message': _("User import finished. Created: %s, Updated: %s") % (created, updated), 'sticky': False}
                )
            except Exception as e:
                _logger.info("Notify failed: %s", e)




        return True

    def _notify(self, msg):
        """Safe, chatter-free notification: bus toast + log."""
        try:
            self.env['bus.bus']._sendone(
                self.env.user.partner_id,
                'simple_notification',
                {'title': _('BioStar'), 'message': msg, 'sticky': False}
            )
        except Exception as e:
            _logger.info("Bus notify failed: %s", e)
        _logger.info(msg)


    # def _extract_users(self, payload):
    #     """Return a list of user dicts or strings from any BioStar user response shape."""
    #     if payload is None:
    #         return []

    #     # If server returned an error envelope, bail out cleanly
    #     if isinstance(payload, dict) and "Response" in payload and "code" in payload["Response"]:
    #         # e.g. {"Response": {"code": 10, "message": "Login is required"}}
    #         _logger.warning("BioStar returned Response error: %s", payload["Response"])
    #         return []

    #     # Common containers seen across versions
    #     if isinstance(payload, dict):
    #         for key in ("records", "data", "users", "UserList", "UserCollection", "Items", "results"):
    #             v = payload.get(key)
    #             if isinstance(v, list):
    #                 return v
    #         # Some APIs return a single user object
    #         return [payload]

    #     # Already a list (could be list of dicts or list of strings)
    #     if isinstance(payload, list):
    #         return payload

    #     # Fallback: server sent plain text / single string identifier(s)
    #     if isinstance(payload, str):
    #         # try to split lines (defensive)
    #         return [line.strip() for line in payload.splitlines() if line.strip()]

    #     return []

    # def action_import_users(self):
    #     for rec in self:
    #         rec._login()

    #         # Prefer the search endpoint; BioStar often uses POST with a Query body.
    #         # If your server accepts GET /api/users, keep it — this will still work.
    #         try:
    #             data = rec._req("POST", "/api/users/search", json={"Query": {}, "Limit": 500})
    #         except Exception:
    #             data = rec._req("GET", "/api/users")

    #         items = rec._extract_users(data)

    #         created, updated = 0, 0
    #         for u in items:
    #             # Normalize each item
    #             if isinstance(u, str):
    #                 uid = u.strip()
    #                 name = uid
    #                 card = None
    #             elif isinstance(u, dict):
    #                 uid = str(
    #                     u.get("user_id")
    #                     or u.get("id")
    #                     or u.get("user_code")
    #                     or u.get("userID")
    #                     or u.get("UserID")
    #                     or ""
    #                 ).strip()
    #                 name = (u.get("name") or u.get("display_name") or u.get("UserName") or uid).strip()
    #                 card = u.get("card") or u.get("card_no") or u.get("CardNo") or None
    #                 if card is not None:
    #                     card = str(card).strip()
    #             else:
    #                 # unknown shape → skip safely
    #                 _logger.warning("Unknown user item shape: %r", u)
    #                 continue

    #             if not uid:
    #                 continue

    #             rec_user = self.env['biostar.user'].sudo().search([
    #                 ('device_id', '=', rec.id),
    #                 ('biostar_user_id', '=', uid)
    #             ], limit=1)

    #             vals = {"name": name or uid}
    #             if card:
    #                 vals["card_no"] = card

    #             if rec_user:
    #                 type(rec_user).write(rec_user, vals)  # avoid any shadowed write
    #                 updated += 1
    #             else:
    #                 vals.update({"device_id": rec.id, "biostar_user_id": uid})
    #                 self.env['biostar.user'].sudo().create(vals)
    #                 created += 1

    #         rec.last_user_sync = fields.Datetime.now()
    #         rec.message_post(body=_("User import finished. Created: %s, Updated: %s") % (created, updated))

    #     return True

    # def action_import_users(self):
    #     for rec in self:
    #         rec._login()
    #         # Adjust to your BioStar endpoint/shape:
    #         data = rec._req("GET", "/api/users")  # may need pagination
    #         items = data.get("records") or data.get("data") or data or []
    #         created, updated = 0, 0
    #         for u in items:
    #             # normalize
    #             uid = str(u.get("user_id") or u.get("id") or u.get("user_code") or "").strip()
    #             name = (u.get("name") or u.get("display_name") or "").strip()
    #             card = (u.get("card") or u.get("card_no") or "") and str(u.get("card") or u.get("card_no"))
    #             if not uid:
    #                 continue
    #             rec_user = self.env['biostar.user'].sudo().search([
    #                 ('device_id','=',rec.id), ('biostar_user_id','=',uid)
    #             ], limit=1)
    #             vals = {"name": name or uid, "card_no": card}
    #             if rec_user:
    #                 rec_user.write(vals)
    #                 updated += 1
    #             else:
    #                 vals.update({"device_id": rec.id, "biostar_user_id": uid})
    #                 self.env['biostar.user'].sudo().create(vals)
    #                 created += 1
    #         rec.last_user_sync = fields.Datetime.now()
    #         rec.message_post(body=_("User import finished. Created: %s, Updated: %s") % (created, updated))
    #     return True

    def action_pull_events(self, since=None, until=None):
        """Fetch attendance events and create hr.attendance.
           Map by hr.employee.barcode (or your custom field)."""
        Attendance = self.env['hr.attendance'].sudo()
        Employee = self.env['hr.employee'].sudo()

        for rec in self:
            rec._login()
            # default range: last 24h
            since_dt = fields.Datetime.from_string(since) if since else (fields.Datetime.now() - timedelta(days=1))
            until_dt = fields.Datetime.from_string(until) if until else fields.Datetime.now()

            # Adjust query/endpoint to BioStar:
            payload = {
                "start_datetime": since_dt.strftime("%Y-%m-%dT%H:%M:%SZ"),
                "end_datetime": until_dt.strftime("%Y-%m-%dT%H:%M:%SZ"),
            }
            events = rec._req("POST", "/api/events/search", json=payload)
            items = events.get("records") or events.get("events") or []

            created = 0
            for ev in items:
                # normalize incoming fields
                uid = str(ev.get("user_id") or ev.get("user_code") or "").strip()
                ts = ev.get("event_time") or ev.get("datetime")
                if not uid or not ts:
                    continue
                # parse as UTC
                punch_dt = fields.Datetime.to_datetime(ts)
                # Map employee
                emp = Employee.search([('barcode', '=', uid)], limit=1)
                if not emp:
                    # try through biostar.user mapping (optional)
                    bs_user = self.env['biostar.user'].sudo().search([
                        ('device_id','=',rec.id), ('biostar_user_id','=',uid), ('employee_id','!=',False)
                    ], limit=1)
                    emp = bs_user.employee_id

                if not emp:
                    _logger.warning("BioStar event with unknown user %s", uid)
                    continue

                # Basic alternating IN/OUT
                last = Attendance.search([('employee_id','=',emp.id)], order='check_in desc', limit=1)
                if not last or last.check_out:
                    Attendance.create({"employee_id": emp.id, "check_in": punch_dt})
                    created += 1
                else:
                    if punch_dt > last.check_in:
                        last.write({"check_out": punch_dt})
            rec.last_event_sync = fields.Datetime.now()
            # rec.message_post(body=_("Events pulled: %s records processed") % created)
            # rec.message_post(body=_("Events pulled: %s records processed") % created)
            self._notify(_("Events pulled: %s records processed") % created)

        return True

    # def action_test_connection(self):
    #     for rec in self:
    #         try:
    #             recc = rec._login()

    #             # Prefer a permissive endpoint first
    #             try:
    #                 _ = recc._req("POST", "/api/devices/search", json={"Query": {}})
    #             except requests.HTTPError as e:
    #                 # Fallback (requires higher perms)
    #                 _ = recc._req("GET", "/api/system")

    #             rec.write({"status": "ok", "status_message": _("Connected")})
    #         except Exception as e:
    #             _logger.exception("BioStar test failed")
    #             rec.write({"status": "error", "status_message": str(e)})
    #             raise

    # def action_test_connection(self):
    #     for rec in self:
    #         try:
    #             recc = rec._login()
    #             # use a permissive endpoint first (or keep /api/system if you’ve fixed perms)
    #             try:
    #                 _ = recc._req("POST", "/api/devices/search", json={"Query": {}})
    #             except Exception:
    #                 _ = recc._req("GET", "/api/system")

    #             # IMPORTANT: re-browse the record so .write is definitely the method
    #             self.browse(rec.id).write({"status": "ok", "status_message": _("Connected")})
    #         except Exception as e:
    #             _logger.exception("BioStar test failed")
    #             self.browse(rec.id).write({"status": "error", "status_message": str(e)})
    #             raise

    def action_test_connection(self):
        for rec in self:
            try:
                recc = rec._login()
                try:
                    _ = recc._req("POST", "/api/devices/search", json={"Query": {}})
                except Exception:
                    _ = recc._req("GET", "/api/system")

                # Bypass any accidental shadowing of `write` on the instance
                # type(rec).write(rec, {"status": "ok", "status_message": _("Connected")})
                rec.write({'status': 'ok',
                           'status_message': 'Connected'})

            except Exception as e:
                _logger.exception("BioStar test failed")
                type(rec).write(rec, {"status": "error", "status_message": str(e)})
                raise
